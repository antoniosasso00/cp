"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/proxy-from-env";
exports.ids = ["vendor-chunks/proxy-from-env"];
exports.modules = {

/***/ "(ssr)/./node_modules/proxy-from-env/index.js":
/*!**********************************************!*\
  !*** ./node_modules/proxy-from-env/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\nvar DEFAULT_PORTS = {\n    ftp: 21,\n    gopher: 70,\n    http: 80,\n    https: 443,\n    ws: 80,\n    wss: 443\n};\nvar stringEndsWith = String.prototype.endsWith || function(s) {\n    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;\n};\n/**\r\n * @param {string|object} url - The URL, or the result from url.parse.\r\n * @return {string} The URL of the proxy that should handle the request to the\r\n *  given URL. If no proxy is set, this will be an empty string.\r\n */ function getProxyForUrl(url) {\n    var parsedUrl = typeof url === \"string\" ? parseUrl(url) : url || {};\n    var proto = parsedUrl.protocol;\n    var hostname = parsedUrl.host;\n    var port = parsedUrl.port;\n    if (typeof hostname !== \"string\" || !hostname || typeof proto !== \"string\") {\n        return \"\"; // Don't proxy URLs without a valid scheme or host.\n    }\n    proto = proto.split(\":\", 1)[0];\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, \"\");\n    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;\n    if (!shouldProxy(hostname, port)) {\n        return \"\"; // Don't proxy URLs that match NO_PROXY.\n    }\n    var proxy = getEnv(\"npm_config_\" + proto + \"_proxy\") || getEnv(proto + \"_proxy\") || getEnv(\"npm_config_proxy\") || getEnv(\"all_proxy\");\n    if (proxy && proxy.indexOf(\"://\") === -1) {\n        // Missing scheme in proxy, default to the requested URL's scheme.\n        proxy = proto + \"://\" + proxy;\n    }\n    return proxy;\n}\n/**\r\n * Determines whether a given URL should be proxied.\r\n *\r\n * @param {string} hostname - The host name of the URL.\r\n * @param {number} port - The effective port of the URL.\r\n * @returns {boolean} Whether the given URL should be proxied.\r\n * @private\r\n */ function shouldProxy(hostname, port) {\n    var NO_PROXY = (getEnv(\"npm_config_no_proxy\") || getEnv(\"no_proxy\")).toLowerCase();\n    if (!NO_PROXY) {\n        return true; // Always proxy if NO_PROXY is not set.\n    }\n    if (NO_PROXY === \"*\") {\n        return false; // Never proxy if wildcard is set.\n    }\n    return NO_PROXY.split(/[,\\s]/).every(function(proxy) {\n        if (!proxy) {\n            return true; // Skip zero-length hosts.\n        }\n        var parsedProxy = proxy.match(/^(.+):(\\d+)$/);\n        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;\n        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;\n        if (parsedProxyPort && parsedProxyPort !== port) {\n            return true; // Skip if ports don't match.\n        }\n        if (!/^[.*]/.test(parsedProxyHostname)) {\n            // No wildcards, so stop proxying if there is an exact match.\n            return hostname !== parsedProxyHostname;\n        }\n        if (parsedProxyHostname.charAt(0) === \"*\") {\n            // Remove leading wildcard.\n            parsedProxyHostname = parsedProxyHostname.slice(1);\n        }\n        // Stop proxying if the hostname ends with the no_proxy host.\n        return !stringEndsWith.call(hostname, parsedProxyHostname);\n    });\n}\n/**\r\n * Get the value for an environment variable.\r\n *\r\n * @param {string} key - The name of the environment variable.\r\n * @return {string} The value of the environment variable.\r\n * @private\r\n */ function getEnv(key) {\n    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || \"\";\n}\nexports.getProxyForUrl = getProxyForUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJveHktZnJvbS1lbnYvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxXQUFXQyw2Q0FBb0I7QUFFbkMsSUFBSUUsZ0JBQWdCO0lBQ2xCQyxLQUFLO0lBQ0xDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLElBQUk7SUFDSkMsS0FBSztBQUNQO0FBRUEsSUFBSUMsaUJBQWlCQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsSUFBSSxTQUFTQyxDQUFDO0lBQzFELE9BQU9BLEVBQUVDLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFDNUIsSUFBSSxDQUFDQyxPQUFPLENBQUNGLEdBQUcsSUFBSSxDQUFDQyxNQUFNLEdBQUdELEVBQUVDLE1BQU0sTUFBTSxDQUFDO0FBQ2pEO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNFLGVBQWVDLEdBQUc7SUFDekIsSUFBSUMsWUFBWSxPQUFPRCxRQUFRLFdBQVdsQixTQUFTa0IsT0FBT0EsT0FBTyxDQUFDO0lBQ2xFLElBQUlFLFFBQVFELFVBQVVFLFFBQVE7SUFDOUIsSUFBSUMsV0FBV0gsVUFBVUksSUFBSTtJQUM3QixJQUFJQyxPQUFPTCxVQUFVSyxJQUFJO0lBQ3pCLElBQUksT0FBT0YsYUFBYSxZQUFZLENBQUNBLFlBQVksT0FBT0YsVUFBVSxVQUFVO1FBQzFFLE9BQU8sSUFBSyxtREFBbUQ7SUFDakU7SUFFQUEsUUFBUUEsTUFBTUssS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUU7SUFDOUIsMEVBQTBFO0lBQzFFLHlEQUF5RDtJQUN6REgsV0FBV0EsU0FBU0ksT0FBTyxDQUFDLFNBQVM7SUFDckNGLE9BQU9HLFNBQVNILFNBQVNyQixhQUFhLENBQUNpQixNQUFNLElBQUk7SUFDakQsSUFBSSxDQUFDUSxZQUFZTixVQUFVRSxPQUFPO1FBQ2hDLE9BQU8sSUFBSyx3Q0FBd0M7SUFDdEQ7SUFFQSxJQUFJSyxRQUNGQyxPQUFPLGdCQUFnQlYsUUFBUSxhQUMvQlUsT0FBT1YsUUFBUSxhQUNmVSxPQUFPLHVCQUNQQSxPQUFPO0lBQ1QsSUFBSUQsU0FBU0EsTUFBTWIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHO1FBQ3hDLGtFQUFrRTtRQUNsRWEsUUFBUVQsUUFBUSxRQUFRUztJQUMxQjtJQUNBLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0QsWUFBWU4sUUFBUSxFQUFFRSxJQUFJO0lBQ2pDLElBQUlPLFdBQ0YsQ0FBQ0QsT0FBTywwQkFBMEJBLE9BQU8sV0FBVSxFQUFHRSxXQUFXO0lBQ25FLElBQUksQ0FBQ0QsVUFBVTtRQUNiLE9BQU8sTUFBTyx1Q0FBdUM7SUFDdkQ7SUFDQSxJQUFJQSxhQUFhLEtBQUs7UUFDcEIsT0FBTyxPQUFRLGtDQUFrQztJQUNuRDtJQUVBLE9BQU9BLFNBQVNOLEtBQUssQ0FBQyxTQUFTUSxLQUFLLENBQUMsU0FBU0osS0FBSztRQUNqRCxJQUFJLENBQUNBLE9BQU87WUFDVixPQUFPLE1BQU8sMEJBQTBCO1FBQzFDO1FBQ0EsSUFBSUssY0FBY0wsTUFBTU0sS0FBSyxDQUFDO1FBQzlCLElBQUlDLHNCQUFzQkYsY0FBY0EsV0FBVyxDQUFDLEVBQUUsR0FBR0w7UUFDekQsSUFBSVEsa0JBQWtCSCxjQUFjUCxTQUFTTyxXQUFXLENBQUMsRUFBRSxJQUFJO1FBQy9ELElBQUlHLG1CQUFtQkEsb0JBQW9CYixNQUFNO1lBQy9DLE9BQU8sTUFBTyw2QkFBNkI7UUFDN0M7UUFFQSxJQUFJLENBQUMsUUFBUWMsSUFBSSxDQUFDRixzQkFBc0I7WUFDdEMsNkRBQTZEO1lBQzdELE9BQU9kLGFBQWFjO1FBQ3RCO1FBRUEsSUFBSUEsb0JBQW9CRyxNQUFNLENBQUMsT0FBTyxLQUFLO1lBQ3pDLDJCQUEyQjtZQUMzQkgsc0JBQXNCQSxvQkFBb0JJLEtBQUssQ0FBQztRQUNsRDtRQUNBLDZEQUE2RDtRQUM3RCxPQUFPLENBQUM5QixlQUFlK0IsSUFBSSxDQUFDbkIsVUFBVWM7SUFDeEM7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNOLE9BQU9ZLEdBQUc7SUFDakIsT0FBT0MsUUFBUUMsR0FBRyxDQUFDRixJQUFJVixXQUFXLEdBQUcsSUFBSVcsUUFBUUMsR0FBRyxDQUFDRixJQUFJRyxXQUFXLEdBQUcsSUFBSTtBQUM3RTtBQUVBQyxzQkFBc0IsR0FBRzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyYm9ucGlsb3QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHJveHktZnJvbS1lbnYvaW5kZXguanM/NThhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcclxuXHJcbnZhciBERUZBVUxUX1BPUlRTID0ge1xyXG4gIGZ0cDogMjEsXHJcbiAgZ29waGVyOiA3MCxcclxuICBodHRwOiA4MCxcclxuICBodHRwczogNDQzLFxyXG4gIHdzOiA4MCxcclxuICB3c3M6IDQ0MyxcclxufTtcclxuXHJcbnZhciBzdHJpbmdFbmRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggfHwgZnVuY3Rpb24ocykge1xyXG4gIHJldHVybiBzLmxlbmd0aCA8PSB0aGlzLmxlbmd0aCAmJlxyXG4gICAgdGhpcy5pbmRleE9mKHMsIHRoaXMubGVuZ3RoIC0gcy5sZW5ndGgpICE9PSAtMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHVybCAtIFRoZSBVUkwsIG9yIHRoZSByZXN1bHQgZnJvbSB1cmwucGFyc2UuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgcHJveHkgdGhhdCBzaG91bGQgaGFuZGxlIHRoZSByZXF1ZXN0IHRvIHRoZVxyXG4gKiAgZ2l2ZW4gVVJMLiBJZiBubyBwcm94eSBpcyBzZXQsIHRoaXMgd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcm94eUZvclVybCh1cmwpIHtcclxuICB2YXIgcGFyc2VkVXJsID0gdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgPyBwYXJzZVVybCh1cmwpIDogdXJsIHx8IHt9O1xyXG4gIHZhciBwcm90byA9IHBhcnNlZFVybC5wcm90b2NvbDtcclxuICB2YXIgaG9zdG5hbWUgPSBwYXJzZWRVcmwuaG9zdDtcclxuICB2YXIgcG9ydCA9IHBhcnNlZFVybC5wb3J0O1xyXG4gIGlmICh0eXBlb2YgaG9zdG5hbWUgIT09ICdzdHJpbmcnIHx8ICFob3N0bmFtZSB8fCB0eXBlb2YgcHJvdG8gIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gJyc7ICAvLyBEb24ndCBwcm94eSBVUkxzIHdpdGhvdXQgYSB2YWxpZCBzY2hlbWUgb3IgaG9zdC5cclxuICB9XHJcblxyXG4gIHByb3RvID0gcHJvdG8uc3BsaXQoJzonLCAxKVswXTtcclxuICAvLyBTdHJpcHBpbmcgcG9ydHMgaW4gdGhpcyB3YXkgaW5zdGVhZCBvZiB1c2luZyBwYXJzZWRVcmwuaG9zdG5hbWUgdG8gbWFrZVxyXG4gIC8vIHN1cmUgdGhhdCB0aGUgYnJhY2tldHMgYXJvdW5kIElQdjYgYWRkcmVzc2VzIGFyZSBrZXB0LlxyXG4gIGhvc3RuYW1lID0gaG9zdG5hbWUucmVwbGFjZSgvOlxcZCokLywgJycpO1xyXG4gIHBvcnQgPSBwYXJzZUludChwb3J0KSB8fCBERUZBVUxUX1BPUlRTW3Byb3RvXSB8fCAwO1xyXG4gIGlmICghc2hvdWxkUHJveHkoaG9zdG5hbWUsIHBvcnQpKSB7XHJcbiAgICByZXR1cm4gJyc7ICAvLyBEb24ndCBwcm94eSBVUkxzIHRoYXQgbWF0Y2ggTk9fUFJPWFkuXHJcbiAgfVxyXG5cclxuICB2YXIgcHJveHkgPVxyXG4gICAgZ2V0RW52KCducG1fY29uZmlnXycgKyBwcm90byArICdfcHJveHknKSB8fFxyXG4gICAgZ2V0RW52KHByb3RvICsgJ19wcm94eScpIHx8XHJcbiAgICBnZXRFbnYoJ25wbV9jb25maWdfcHJveHknKSB8fFxyXG4gICAgZ2V0RW52KCdhbGxfcHJveHknKTtcclxuICBpZiAocHJveHkgJiYgcHJveHkuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XHJcbiAgICAvLyBNaXNzaW5nIHNjaGVtZSBpbiBwcm94eSwgZGVmYXVsdCB0byB0aGUgcmVxdWVzdGVkIFVSTCdzIHNjaGVtZS5cclxuICAgIHByb3h5ID0gcHJvdG8gKyAnOi8vJyArIHByb3h5O1xyXG4gIH1cclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBVUkwgc2hvdWxkIGJlIHByb3hpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIFRoZSBob3N0IG5hbWUgb2YgdGhlIFVSTC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgLSBUaGUgZWZmZWN0aXZlIHBvcnQgb2YgdGhlIFVSTC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgcHJveGllZC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNob3VsZFByb3h5KGhvc3RuYW1lLCBwb3J0KSB7XHJcbiAgdmFyIE5PX1BST1hZID1cclxuICAgIChnZXRFbnYoJ25wbV9jb25maWdfbm9fcHJveHknKSB8fCBnZXRFbnYoJ25vX3Byb3h5JykpLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKCFOT19QUk9YWSkge1xyXG4gICAgcmV0dXJuIHRydWU7ICAvLyBBbHdheXMgcHJveHkgaWYgTk9fUFJPWFkgaXMgbm90IHNldC5cclxuICB9XHJcbiAgaWYgKE5PX1BST1hZID09PSAnKicpIHtcclxuICAgIHJldHVybiBmYWxzZTsgIC8vIE5ldmVyIHByb3h5IGlmIHdpbGRjYXJkIGlzIHNldC5cclxuICB9XHJcblxyXG4gIHJldHVybiBOT19QUk9YWS5zcGxpdCgvWyxcXHNdLykuZXZlcnkoZnVuY3Rpb24ocHJveHkpIHtcclxuICAgIGlmICghcHJveHkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7ICAvLyBTa2lwIHplcm8tbGVuZ3RoIGhvc3RzLlxyXG4gICAgfVxyXG4gICAgdmFyIHBhcnNlZFByb3h5ID0gcHJveHkubWF0Y2goL14oLispOihcXGQrKSQvKTtcclxuICAgIHZhciBwYXJzZWRQcm94eUhvc3RuYW1lID0gcGFyc2VkUHJveHkgPyBwYXJzZWRQcm94eVsxXSA6IHByb3h5O1xyXG4gICAgdmFyIHBhcnNlZFByb3h5UG9ydCA9IHBhcnNlZFByb3h5ID8gcGFyc2VJbnQocGFyc2VkUHJveHlbMl0pIDogMDtcclxuICAgIGlmIChwYXJzZWRQcm94eVBvcnQgJiYgcGFyc2VkUHJveHlQb3J0ICE9PSBwb3J0KSB7XHJcbiAgICAgIHJldHVybiB0cnVlOyAgLy8gU2tpcCBpZiBwb3J0cyBkb24ndCBtYXRjaC5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIS9eWy4qXS8udGVzdChwYXJzZWRQcm94eUhvc3RuYW1lKSkge1xyXG4gICAgICAvLyBObyB3aWxkY2FyZHMsIHNvIHN0b3AgcHJveHlpbmcgaWYgdGhlcmUgaXMgYW4gZXhhY3QgbWF0Y2guXHJcbiAgICAgIHJldHVybiBob3N0bmFtZSAhPT0gcGFyc2VkUHJveHlIb3N0bmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyc2VkUHJveHlIb3N0bmFtZS5jaGFyQXQoMCkgPT09ICcqJykge1xyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB3aWxkY2FyZC5cclxuICAgICAgcGFyc2VkUHJveHlIb3N0bmFtZSA9IHBhcnNlZFByb3h5SG9zdG5hbWUuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICAvLyBTdG9wIHByb3h5aW5nIGlmIHRoZSBob3N0bmFtZSBlbmRzIHdpdGggdGhlIG5vX3Byb3h5IGhvc3QuXHJcbiAgICByZXR1cm4gIXN0cmluZ0VuZHNXaXRoLmNhbGwoaG9zdG5hbWUsIHBhcnNlZFByb3h5SG9zdG5hbWUpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEVudihrZXkpIHtcclxuICByZXR1cm4gcHJvY2Vzcy5lbnZba2V5LnRvTG93ZXJDYXNlKCldIHx8IHByb2Nlc3MuZW52W2tleS50b1VwcGVyQ2FzZSgpXSB8fCAnJztcclxufVxyXG5cclxuZXhwb3J0cy5nZXRQcm94eUZvclVybCA9IGdldFByb3h5Rm9yVXJsO1xyXG4iXSwibmFtZXMiOlsicGFyc2VVcmwiLCJyZXF1aXJlIiwicGFyc2UiLCJERUZBVUxUX1BPUlRTIiwiZnRwIiwiZ29waGVyIiwiaHR0cCIsImh0dHBzIiwid3MiLCJ3c3MiLCJzdHJpbmdFbmRzV2l0aCIsIlN0cmluZyIsInByb3RvdHlwZSIsImVuZHNXaXRoIiwicyIsImxlbmd0aCIsImluZGV4T2YiLCJnZXRQcm94eUZvclVybCIsInVybCIsInBhcnNlZFVybCIsInByb3RvIiwicHJvdG9jb2wiLCJob3N0bmFtZSIsImhvc3QiLCJwb3J0Iiwic3BsaXQiLCJyZXBsYWNlIiwicGFyc2VJbnQiLCJzaG91bGRQcm94eSIsInByb3h5IiwiZ2V0RW52IiwiTk9fUFJPWFkiLCJ0b0xvd2VyQ2FzZSIsImV2ZXJ5IiwicGFyc2VkUHJveHkiLCJtYXRjaCIsInBhcnNlZFByb3h5SG9zdG5hbWUiLCJwYXJzZWRQcm94eVBvcnQiLCJ0ZXN0IiwiY2hhckF0Iiwic2xpY2UiLCJjYWxsIiwia2V5IiwicHJvY2VzcyIsImVudiIsInRvVXBwZXJDYXNlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/proxy-from-env/index.js\n");

/***/ })

};
;