#!/usr/bin/env python3\n\"\"\"\nDebug specifico per il solver 2L - Identificazione del problema\n\"\"\"\n\nimport requests\nimport json\nimport time\nimport sys\nimport os\n\n# Aggiungi il path del backend\nsys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))\n\ndef test_2l_solver_debug():\n    \"\"\"Debug approfondito del solver 2L\"\"\"\n    \n    print(\"üîß === DEBUG SOLVER 2L ===\\n\")\n    \n    # Test 1: Database connection\n    try:\n        from backend.api.database import SessionLocal\n        from backend.models import ODL, Autoclave, Tool, Parte\n        from sqlalchemy.orm import joinedload\n        \n        db = SessionLocal()\n        print(\"‚úÖ Database connesso\")\n        \n        # Test 2: Verifica autoclavi con supporto 2L\n        autoclavi = db.query(Autoclave).all()\n        autoclavi_2l = [a for a in autoclavi if a.usa_cavalletti]\n        \n        print(f\"üìä Autoclavi totali: {len(autoclavi)}\")\n        print(f\"üìä Autoclavi con cavalletti: {len(autoclavi_2l)}\")\n        \n        if not autoclavi_2l:\n            print(\"‚ùå PROBLEMA: Nessuna autoclave con supporto cavalletti!\")\n            # Fix: abilita cavalletti per almeno un'autoclave\n            if autoclavi:\n                autoclave = autoclavi[0]\n                autoclave.usa_cavalletti = True\n                db.commit()\n                print(f\"‚úÖ FIX: Abilitati cavalletti per autoclave {autoclave.nome}\")\n                autoclavi_2l = [autoclave]\n        \n        # Test 3: Verifica ODL disponibili\n        odls = db.query(ODL).options(\n            joinedload(ODL.tool),\n            joinedload(ODL.parte)\n        ).filter(ODL.status == \"Attesa Cura\").all()\n        \n        print(f\"üìä ODL in Attesa Cura: {len(odls)}\")\n        \n        if len(odls) < 2:\n            print(\"‚ö†Ô∏è Pochi ODL disponibili - test limitato\")\n            return\n        \n        # Test 4: Test solver 2L diretto\n        try:\n            from backend.services.nesting.solver_2l import NestingModel2L, NestingParameters2L\n            from backend.api.routers.batch_nesting_modules.generation import _convert_db_to_tool_info_2l, _convert_db_to_autoclave_info_2l\n            \n            print(\"\\nüöÄ Test solver 2L diretto...\")\n            \n            # Prendi prima autoclave con cavalletti\n            autoclave = autoclavi_2l[0]\n            print(f\"   Autoclave: {autoclave.nome} (cavalletti: {autoclave.usa_cavalletti})\")\n            \n            # Prendi primi 3 ODL per test\n            test_odls = odls[:3]\n            print(f\"   ODL test: {[odl.id for odl in test_odls]}\")\n            \n            # Converti in formato 2L\n            tools_2l = []\n            for odl in test_odls:\n                if odl.tool and odl.parte:\n                    tool_2l = _convert_db_to_tool_info_2l(odl, odl.tool, odl.parte)\n                    tools_2l.append(tool_2l)\n                    print(f\"   Tool ODL {odl.id}: {tool_2l.width}x{tool_2l.height}mm, {tool_2l.weight}kg\")\n            \n            if not tools_2l:\n                print(\"‚ùå PROBLEMA: Nessun tool valido per conversione 2L\")\n                return\n            \n            # Converti autoclave\n            autoclave_2l = _convert_db_to_autoclave_info_2l(autoclave)\n            autoclave_2l.has_cavalletti = True\n            print(f\"   Autoclave 2L: {autoclave_2l.width}x{autoclave_2l.height}mm, cavalletti: {autoclave_2l.has_cavalletti}\")\n            \n            # Configura parametri\n            parameters_2l = NestingParameters2L(\n                padding_mm=5.0,\n                min_distance_mm=10.0,\n                vacuum_lines_capacity=autoclave.num_linee_vuoto or 20,\n                use_cavalletti=True,\n                prefer_base_level=True,\n                allow_heuristic=True,\n                use_multithread=False,  # Disabilita multithread per debug\n                base_timeout_seconds=30.0,\n                max_timeout_seconds=60.0\n            )\n            \n            # Test solver\n            solver_2l = NestingModel2L(parameters_2l)\n            print(\"\\nüî¨ Esecuzione solver 2L...\")\n            \n            start_time = time.time()\n            solution_2l = solver_2l.solve_2l(tools_2l, autoclave_2l)\n            end_time = time.time()\n            \n            print(f\"\\nüìä RISULTATI SOLVER 2L:\")\n            print(f\"   Successo: {solution_2l.success}\")\n            print(f\"   Algorithm: {solution_2l.algorithm_status}\")\n            print(f\"   Tool posizionati: {len(solution_2l.layouts)}\")\n            print(f\"   Tool esclusi: {len(solution_2l.excluded_odls)}\")\n            print(f\"   Tempo: {(end_time - start_time):.2f}s\")\n            print(f\"   Efficienza: {solution_2l.metrics.efficiency_score:.1f}%\")\n            \n            if solution_2l.success and len(solution_2l.layouts) > 0:\n                print(\"‚úÖ SOLVER 2L FUNZIONA CORRETTAMENTE!\")\n                \n                # Analizza distribuzione livelli\n                level_0_count = sum(1 for l in solution_2l.layouts if l.level == 0)\n                level_1_count = sum(1 for l in solution_2l.layouts if l.level == 1)\n                print(f\"   Livello 0: {level_0_count} tool\")\n                print(f\"   Livello 1: {level_1_count} tool\")\n                \n                return True\n            else:\n                print(\"‚ùå SOLVER 2L FALLISCE\")\n                print(f\"   Messaggio: {solution_2l.message}\")\n                return False\n                \n        except Exception as solver_error:\n            print(f\"‚ùå ERRORE SOLVER 2L: {solver_error}\")\n            import traceback\n            traceback.print_exc()\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå ERRORE GENERALE: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    finally:\n        if 'db' in locals():\n            db.close()\n\ndef test_http_endpoint():\n    \"\"\"Test dell'endpoint HTTP 2L-multi\"\"\"\n    \n    print(\"\\nüåê === TEST ENDPOINT HTTP 2L-MULTI ===\\n\")\n    \n    try:\n        # Payload minimale per test\n        payload = {\n            \"autoclavi_2l\": [1],  # Solo prima autoclave\n            \"odl_ids\": [5, 6, 7],  # Primi 3 ODL\n            \"parametri\": {\n                \"padding_mm\": 5,\n                \"min_distance_mm\": 10\n            },\n            \"use_cavalletti\": True,\n            \"prefer_base_level\": True\n        }\n        \n        print(f\"üìã Payload: {json.dumps(payload, indent=2)}\")\n        \n        response = requests.post(\n            \"http://localhost:8000/api/batch_nesting/2l-multi\",\n            json=payload,\n            timeout=120\n        )\n        \n        print(f\"\\nüìä RISPOSTA HTTP:\")\n        print(f\"   Status: {response.status_code}\")\n        \n        if response.status_code == 200:\n            data = response.json()\n            print(f\"   Success: {data.get('success', False)}\")\n            print(f\"   Message: {data.get('message', 'N/A')}\")\n            print(f\"   Batch count: {data.get('success_count', 0)}\")\n            print(\"‚úÖ ENDPOINT HTTP FUNZIONA!\")\n            return True\n        else:\n            print(f\"   Error: {response.text}\")\n            print(\"‚ùå ENDPOINT HTTP FALLISCE\")\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå ERRORE HTTP: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    print(\"üîß DIAGNOSI COMPLETA SOLVER 2L\")\n    print(\"=\" * 50)\n    \n    # Test in sequenza\n    solver_ok = test_2l_solver_debug()\n    \n    if solver_ok:\n        print(\"\\n\" + \"=\" * 50)\n        endpoint_ok = test_http_endpoint()\n        \n        if endpoint_ok:\n            print(\"\\nüéâ TUTTI I TEST PASSATI - PROBLEMA RISOLTO!\")\n        else:\n            print(\"\\n‚ö†Ô∏è SOLVER OK MA ENDPOINT FALLISCE - Problema nella serializzazione/endpoint\")\n    else:\n        print(\"\\n‚ùå PROBLEMA NEL SOLVER 2L - Richiede fix algoritmo\")\n 